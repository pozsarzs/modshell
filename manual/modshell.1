.TH ModShell 1 "2024 Szeptember 30" ""
.SH NAME
modshell \- Command-driven scriptable Modbus utility
.SH SYNOPSIS
.B modshell
[options]
.SH COPYRIGHT
ModShell is Copyright (C) 2023-2024 by Pozsar Zsolt.
.SH DESCRIPTION
This is a utility that can be used on several operating systems, which
can communicate with connected equipment using Modbus/ASCII, Modbus/RTU
and Modbus/TCP protocols. The basic communication protocol of the program
is Modbus, but DCON was also implemented due to communication with other
devices (e.g. ADAM). The range of foreign protocols may be expanded later.
The program is designed for DOS, Windows and Unix-like operating systems.
.SH OPTIONS
.TP
.B \-f \-\-fullscreen
Start in full screen mode.
.TP
.B \-h \-\-help
Write useable parameters.
.TP
.B \-r \-\-run script
Run a script.
.TP
.B \-v \-\-version
Write version and build information.
.SH OPERATION
The program can - even automatically - read, write or copy data from one device
to another (e.g. transferring settings). When copying, the source and
destination register areas can be different.
.PP
The program has a traditional (CLI) or full-screen (TUI) command-line interface
and is also suitable for running pre-created scripts independently (as a command
interpreter). The program provides help on the commands that can be used, and
offers possible values when the parameters are entered incorrectly. The issued
commands are placed in history, which can be browsed with the up/down arrow keys.
.SS Operating principle
It must be defined the I/O devices, then the protocols and the connections.
There can be eight of each. The data traffic takes place between the preset
connections. In all cases, the data is sent to or read from the internal buffer.
The size of the buffer is suitable for storing 2*9999 logical and word values of
the same size. One hundred and twenty-eight variables or constants can be created
in the program, to which we can assign a value of any type (eg.: message, boolean
or integer register value, etc.) Variables and constants can be used to perform
logical and basic mathematical operations, and can be used to pass values to commands.
.SS Projects
In the program, you can create projects for easier management of settings and
data. The name of the current project is shown in the prompt. The project
directory will be created in the program directory on DOS, and in the ModShell
directory in the user's home directory on all other systems. If only filename
is specified during file operations (without path), this directory will be the
source/destination directory.
.SS File operations
The command line history can be exported to a text file and provides it with the
appropriate 'shebang' for all operating system. You can easily create a script
from this raw file.
.PP
Device, protocol and connection settings can be saved and loaded in their own
format. During saving, three typed files are created, with the following
extensions: DDT, PDT, CDT.
.PP
All register values can be saved and loaded in their own format. During saving,
two typed files are created, with the following extensions: BDT, WDT.
.PP
One or more same type registers can be exported to file. During saving, one text
file is created, with CSV, INI or XML extension. The program can only import from
INI and XML format files.
.PP
The program has a simple serial console whose traffic is logged in the project
directory as console.log.
.PP
On exit, the command line history, echo mode and colors are preserved.
.PP
The program also has basic file and directory management commands.
.SS Script operations
The script on the disc can be loaded into the already running program and started
manually.The loaded script can be edited with a line editor, saved to disk or
deleted from the buffer. The graphical version has a simple editor window
with syntax highlighting instead of the line editor.
Variables and constants defined before running the script will be deleted.
It is also possible to observe the values of up to four variables during
runtime and to keep the final values​of constants and variables created
during runtime.
.SS Serial console
The program also provides the possibility to send and receive raw data
via a serial port, and also includes a very simple serial console. The
display of sent and received data can be turned off or raw text and
hexadecimal viewing can be selected.
.SH PREDEFINED CONSTANTS
.TP
\fB$?\fP
Exit value of the commands.
.TP
\fB$B1\fP
1200 (baud).
.TP
\fB$B2\fP
2400 (baud).
.TP
\fB$B41\fP
4800 (baud).
.TP
\fB$B8\fP
9600 (baud).
.TP
\fB$B19\fP
19200 (baud).
.TP
\fB$B38\fP
38400 (baud).
.TP
\fB$B57\fP
57600 (baud).
.TP
\fB$B115\fP
115200 (baud).
.TP
\fB$PI\fP
Value of Pi (3.1415926535897932385).
.TP
\fB$EULER\fP
Value of e  (2.7182818284590452354).
.TP
\fB$HOME\fP
User's home directory.
.TP
\fB$PRJDIR\fP
Directory of the actual project.
.TP
\fB$PRJNAME\fP
Name of the actual project.
.SH BUILTIN COMMANDS
Notes:
  - register: local buffer register
  - remote register: register of the connected device
  - The '$' sign indicates value of a variable or constant not a direct value.
  - The symbol '[x]' indicates the element number of a variable or constant array.
  - The exit value of the commands is in the '$?' constant.

.SS Arithmetical commands
.TP
\fBadd\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Adds the two values or variables (\fI[$]VALUE1\fP \fI[$]VALUE2\fP)
and the result is placed in \fI$TARGET\fP.
.TP
\fBavg\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP \fI[[$]VALUE3...6]\fP
Calculates average of 2-5 numbers and the result is placed in \fI$TARGET\fP.
.TP
\fBconv\fP \fI$TARGET\fP \fIbin\fP|\fIdec\fP|\fIhex\fP|\fIoct\fP \fIbin\fP|\fIdec\fP|\fIhex\fP|\fIoct\fP \fI[$]VALUE\fP
Converts numbers between binary, decimal, hexadecimal and octal numeral system. Result is placed in \fI$TARGET\fP variable.
\fIVALUE\fP must be between 0 and 65535
.TP
\fBcos\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates cosine of \fI[$]VALUE\fP and
the result is placed in \fI$TARGET\fP.
.TP
\fBcotan\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates cotangent of \fI[$]VALUE\fP
and the result is placed in \fI$TARGET\fP.
.TP
\fBdec\fP \fI$VARIABLE\fP
Decrements \fI$VARIABLE\fP integer.
.TP
\fBdiv\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Divides \fI[$]VALUE1\fP by \fI[$]VALUE2\fP and the result
is placed in \fI$TARGET\fP.
.TP
\fBexp\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates natural exponential of \fI[$]VALUE\fP
and the result is placed in \fI$TARGET\fP.
.TP
\fBidiv\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Divides \fI[$]VALUE1\fP by \fI[$]VALUE2\fP and the result
is placed in \fI$TARGET\fP. (integer division)
.TP
\fBimod\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Divides \fI[$]VALUE1\fP by \fI[$]VALUE2\fP and the result
is placed in \fI$TARGET\fP. (modulus division)
.TP
\fBinc\fP \fI$VARIABLE\fP
Increments \fI$VARIABLE\fP integer.
.TP
\fBln\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates natural logarithm of \fI[$]VALUE\fP
and the result is placed in \fI$TARGET\fP.
.TP
\fBmul\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Multiplies the two two values or variables (\fI[$]VALUE1\fP \fI[$]VALUE2\fP)
and the result is placed in \fI$TARGET\fP.
.TP
\fBmulinv\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates multiplicative inverse of \fI[$]VALUE\fP
and the result is placed in \fI$TARGET\fP.
.TP
\fBodd\fP \fI$TARGET\fP \fI[$]VALUE\fP
Decides whether the integer \fI[$]VALUE\fP is even or odd.
.TP
\fBpow\fP \fI$TARGET\fP \fI[$]BASE\fP \fI[$]EXPONENT\fP
Calculates \fI[$]EXPONENT\fP exponentiation of the \fI[$]BASE\fP
and the result is placed in \fI$TARGET\fP.
.TP
\fBpow2\fP \fI$TARGET\fP \fI[$]EXPONENT\fP
Calculates \fI[$]EXPONENT\fP exponentiation of two
and the result is placed in \fI$TARGET\fP.
.TP
\fBprop\fP \fI$TARGET\fP \fI[$]MIN\fP \fI[$]MAX\fP \fI[$]ZERO\fP \fI[$]SPAN\fP \fI[$]VALUE\fP
Propotional value calculation (for example: 4-20 mA current loop and measured value).
.TP
\fBrnd\fP \fI$TARGET\fP \fI[$]VALUE\fP
Makes random integer number between 0 and
\fI[$]VALUE\fP and the result
is placed in \fI$TARGET\fP.
.TP
\fBround\fP \fI$TARGET\fP \fI[$]VALUE\fP \fI[$]DEC_PLACES\fP
Rounds value or variable (\fI[$]VALUE\fP) to \fI[$]DEC_PLACES\fP decimal places
and the result is placed in \fI$TARGET\fP.
.TP
\fBsin\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates sine of \fI[$]VALUE\fP and the
result is placed in \fI$TARGET\fP.
.TP
\fBsqr\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates square of \fI[$]VALUE\fP and
the result is placed in \fI$TARGET\fP.
.TP
\fBsqrt\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates square root of \fI[$]VALUE\fP and
the result is placed in \fI$TARGET\fP.
.TP
\fBsub\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Substracts \fI[$]VALUE2\fP from \fI[$]VALUE1\fP and the result
is placed in \fI$TARGET\fP.
.TP
\fBtan\fP \fI$TARGET\fP \fI[$]VALUE\fP
Calculates tangent of \fI[$]VALUE\fP and
the result is placed in \fI$TARGET\fP.

.SS Communication commands
.TP
\fBcopyreg\fP \fIcon?\fP \fIdinp\fP|\fIcoil\fP \fIcon?\fP \fIcoil?\fP \fI[$]ADDRESS\fP [\fI[$]COUNT\fP]
Copies logical data between connections (\fIcon?\fP). Number of connection
(\fIcon?\fP) must be between 0-7, register start \fIADDRESS\fP and the
\fICOUNT\fP must be between 1-9999.
.TP
\fBcopyreg\fP \fIcon?\fP \fIireg\fP|\fIhreg\fP \fIcon?\fP \fIhreg?\fP \fI[$]ADDRESS\fP [\fI[$]COUNT\fP]
Copies numeral data between connections (\fIcon?\fP). Number of connection
(\fIcon?\fP) must be between 0-7, register start \fIADDRESS\fP and the
\fICOUNT\fP must be between 1-9999.
.TP
\fBdcon\fP \fIcon?\fP \fI$TXARRAY\fP \fI$RXARRAY\fP
Reads or writes data from/to remote device with DCON protocol. The command
takes the input data from the \fI$TXARRAY\fP array, the output data is placed in
the \fI$RXARRAY\fP. Both arrays can only be variable arrays. If necessary, arrays
are resized by the command.
.EX

\fI$$TXARRAY\fP:
[0]  delimiter [$, #, %, @]
[1]  command
[2]  input data
[3]  checksum enable/disable [1/0]

\fI$$RXARRAY\fP:
[0]  delimiter [!, ?, >]
[1]  command (non used)
[2]  output data
[3]  checksum, output data is correct or not [1/0]

.EE
.TP
\fBmbgw\fP \fIcon?\fP \fIcon?\fP
Start internal Modbus slave/server for remote access own registers.
.TP
\fBmbsrv\fP \fIcon?\fP
Start internal Modbus gateway for access other remote device's registers with
different communication and/or protocol.
.TP
\fBreadreg\fP \fIcon?\fP \fIdinp\fP|\fIcoil\fP|\fIireg\fP|\fIhreg\fP \fI[$]ADDRESS\fP [\f[$]ICOUNT\fP]
Reads one or more remote registers. Number of connection (\fIcon?\fP)
must be between 0-7, register start \fIADDRESS\fP and the \fICOUNT\fP must be
between 1-9999.
.TP
\fBsercons\fP \fI[dev?]\fP
Opens a simple serial console. Data traffic is logged to the project directory
named \fIconsole.log\fP. Number of device (\fIdev?\fP) must be between 0-7.
.TP
\fBserread\fP \fI[dev?]\fP \fI[$TARGET]\fP
Reads string from serial device to variable \fI$TARGET\fP or write screen.
Number of device (\fIdev?\fP) must be between 0-7.
.TP
\fBserwrite\fP \fI[dev?]\fP \fI$MESSAGE\fP
Writes string to serial device from \fI$MESSAGE\fP.
Number of device (\fIdev?\fP) must be between 0-7.
.TP
\fBserwrite\fP \fI[dev?]\fP \fI"MESSAGE"\fP
Writes "MESSAGE" to serial device. Number of device (\fIdev?\fP) must be between 0-7.
.TP
\fBwritereg\fP \fIcon?\fP \fIcoil\fP|\fIhreg\fP \fI[$]ADDRESS\fP [\fI[$]COUNT\fP]
Writes data to one or more remote registers. Number of connection
(\fIcon?\fP) must be between 0-7, register start address and the count must be
between 1-9999.

.SS Configuration commands
.TP
\fBget\fP \fIdev?\fP|\fIpro?\fP|\fIcon?\fP|\fIproject\fP|\fItimeout\fP
Gets configuration of a device (\fIdev?\fP), protocol (\fIpro?\fP) or connection
(\fIcon?\fP), or project name (\fIproject\fP) or connection timeout (\fItimeout\fP) in s.
? number must be 0-7, timeout must be 1-60.
.TP
\fBreset\fP \fIdev?\fP|\fIpro?\fP|\fIcon?\fP|\fIproject\fP
Resets configuration of a device (\fIdev?\fP), protocol (\fIpro?\fP) or connection
(\fIcon?\fP), or reset project name (\fIproject\fP). ? number must be 0-7.
.TP
\fBset\fP \fIdev?\fP \fInet\fP \fI[$]DEVICE\fP \fI[$]IP_ADDRESS\fP \fI[$]PORT\fP
Sets device (\fIdev?\fP) to ethernet (\fInet\fP) device. Device number must be
between 0-7 and port number must be between 0-65535. The \fIDEVICE\fP name on
DOS is always PACKET, on other systems is the name of the adapter (e.g. eth0,
nfe0, etc.). Address of remote device (\fIIP_ADDRESS\fP) must be in a.b.c.d format,
with values between 1-255.
.TP
\fBset\fP \fIdev?\fP \fIser\fP \fI[$]DEVICE\fP \fI[$]BAUDRATE\fP \fI[$]DATABIT\fP \fI[$]PARITY\fP \fI[$]STOPBIT\fP
Sets device (\fIdev?\fP) to serial (\fIser\fP) device. Device number must be
between 0-7. The \fIDEVICE\fP name is the name of the adapter (e.g. com1, ttyS0,
ttyUSB0, ttyAMA0 etc.). \fIBAUDRATE\fP must be: 1200; 2400; 4800; 9600; 19200;
38400; 57600 or 115200. \fIDATABIT\fP must be 7 or 8, \fIPARITY\fP must be E/N/O
(even/none/odd). \fISTOPBIT\fP must be 1 or 2.
.TP
\fBset\fP \fIpro?\fP \fIascii\fP|\fIrtu\fP|\fItcp\fP \fI[$]ID\fP
Sets protocol (\fIpro?\fP) and unit ID. Unit ID (\fIID\fP) must be between 1-247.
.TP
\fBset\fP \fIpro?\fP \fIdcon\fP \fI[$]ADDRESS\fP
Sets protocol (\fIpro?\fP) to DCON (\fIdcon\fP). Address of remote device
(\fIADDRESS\fP) must be between 1-255.
.TP
\fBset\fP \fIcon?\fP \fIdev?\fP \fIpro?\fP
Assigns a device (\fIdev?\fP) and a protocol (\fIpro?\fP) to a connection
(\fIcon?\fP). ? number must be 0-7.
.TP
\fBset\fP \fIcolor\fP \fI[$]FOREGROUND\fP \fI[$]BACKGROUND\fP \fI[$]RXD_TEXT\fP \fI[$]TXD_TEXT\fP \fI[$]VARMON\fP
Sets all default colors in CLI and TUI mode.
.EX

\fIColors:\fP
0: black  4: red         8: darkgray    12: lightred
1: blue   5: magenta:    9: lightblue   13: lightmagenta
2: green  6: brown      10: lightgreen  14: yellow
3: cyan   7: lightgray  11: lightcyan   15: white
.EE
.TP
\fBset\fP \fIproject\fP [$]PROJECT_NAME
Sets the project name. The name cannot contain spaces or special characters.
The project directory will also be created with this name.
.TP
\fBset\fP \fItimeout\fP [$]TIMEOUT
Sets the connection timeout in ms.

.SS File operation commands
The specified parameter does not contain a path, the file will be saved in the
project directory in the user's home directory (on DOS, in project directory
in the program directory).
.TP
\fBapplog\fP \fI[$]LOGFILE\fP \fI$TEXT\fP \fI[$]LEVEL\fP \fI[[$]VALUE1]\fP ... \fI[[$]VALUE4]\fP
Appends a record to \fI$LOGFILE\fP. The record contains timestamp, message level and the
text. The level can be 0-4: NOTE, MESSAGE, WARNING, ERROR, DEBUG. The text contains
the level can contain $$1-$4 variables, these can be specified on the command line.
.TP
\fBapplog\fP \fI[$]LOGFILE\fP "TEXT\ $$1\ TEXT"\fP \fI[$]LEVEL\fP \fI[[$]VALUE1]\fP
Appends a record to \fI$LOGFILE\fP. The record contains timestamp, message level and the
text. The level can be 0-4: NOTE, MESSAGE, WARNING, ERROR, DEBUG. The text contains
the level can contain $$1-$4 variables, these can be specified on the command line.
.TP
\fBexphis\fP \fI[$]PATH_AND_FILENAME\fP
Exports command line history to a text file.
.TP
\fBexpreg\fP \fI[$]PATH_AND_FILENAME\fP \fIdinp\fP|\fIcoil\fP|\fIireg\fP|\fIhreg\fP \fI[$]ADDRESS\fP [\fI[$]COUNT\fP]
Exports content of the one or more registers to a text file in CSV, INI
or XML format. The file format is specified by the destination file extension.
If the file exists, it will overwrite or append the new data.
.TP
\fBimpreg\fP \fI[$]PATH_AND_FILENAME\fP
Imports content of the one or more registers from a text file in INI
or XML format. The file format is specified by the destination file extension.
.TP
\fBloadcfg\fP \fI[$]PATH_AND_FILENAME\fP
Loads settings of device, protocol and connection from own format files.
.TP
\fBloadreg\fP \fI[$]PATH_AND_FILENAME\fP
Loads all registers from own format files.
.TP
\fBsavecfg\fP \fI[$]PATH_AND_FILENAME\fP
Saves settings of device, protocol and connection to four typed files.
.TP
\fBsavereg\fP \fI[$]PATH_AND_FILENAME\fP
Saves all registers to four typed files.

.SS General commands
.TP
\fBarrclear\fP \fIARRAY\fP
Clears content of an array.
.TP
\fBarrfill\fP \fIARRAY\fP \fI[$]DATA\fP
Fills an array with \fI[$]DATA\fP.
.TP
\fBascii\fP \fI[dec|hex]\fP
Shows ASCII table (0-127 characters) with decimal or hexadecimal numbers.
.TP
\fBbeep\fP
Make a beep.
.TP
\fBcarr\fP
Prints constant arrays with their size.
.TP
\fBcarr\fP \fIARRAY\fP
Defines new zero size \fIARRAY\fP constant array.
.TP
\fBcarr\fP \fIARRAY\fP \fISIZE\fP
Defines new \fISIZE\fP size \fIARRAY\fP constant array.
.TP
\fBcls\fP
Clears screen.
.TP
\fBconst\fP \fICONSTANT\fP [\fI[$]VALUE\fP]
Defines new constant (\fICONSTANT\fP) and assign value (\fIVALUE\fP).
Use a backslash before a space.
.TP
\fBcron\fP \fIrec_num\fP \fIminute\fP \fIhour\fP
Adds new record to crontable. \fIrec_num\fP may be 1-4.
.TP
\fBcron\fP [\fI-r rec_num\fP]
Shows all or removes specified record from the crontable. \fIrec_num\fP may be 1-4.
.TP
\fBdate\fP [\fI$TARGET\fP]
Shows or write into \fI$TARGET\fP variable system date and time.
.TP
\fBecho\fP [\fIoff\fP|\fIon\fP|\fIhex\fP]
Queries local echo status or enable/disable it for serial connections.
Hex means the hexadecimal representation of the bytes.
.TP
\fBexit\fP
Exits from program.
.TP
\fBgetarrsize\fP \fIARRAY\fP \fI$TARGET\fP
Gets size of an array and placed in _$TARGET_.
.TP
\fBgoto\fP \fILABEL\fP
Jumps to specified label (only in script).
.TP
\fBfor\fP \fI$VARIABLE\fP \fI[$]VALUE1\fP \fBto\fP \fI[$]VALUE2\fP \fBdo\fP \fICOMMAND\fP
Loop iteration (only in script). Increments \fI$VARIABLE\fP from \fI[$]VALUE1\fP to \fI[$]VALUE2\fP
and does \fICOMMAND\fP.
.TP
\fBhelp\fP \fI[[$]COMMAND]\fP
Shows description or usage of the builtin commands.
.TP
\fBif\fP \fI[$]VALUE1\fP \fBRELATIONAL_SIGN\fP \fI[$]VALUE2\fP \fBthen\fP \fICOMMAND\fP
Selection statement (only in script). \fBRELATIONAL_SIGN\fP: < <= = >= >.
.TP
\fBlabel\fP \fILABEL\fP
Define label (only in script).
.TP
\fBlet\fP \fI$VARIABLE\fP \fI[$]VALUE\fP
Sets value of \fI$VARIABLE\fP variable or constant to value \fI[$]VALUE\fP.
.TP
\fBlet\fP \fI$VARIABLE\fP \fInul\fP
Clear \fI$VARIABLE\fP variable content.
.TP
\fBpause\fP \fI[[$]TIME]\fP
Waits for a keystroke or specified time.
.TP
\fBprint\fP \fIdinp\fP|\fIcoil\fP|\fIireg\fP|\fIhreg\fP \fI[$]ADDRESS\fP [\fI[$]COUNT\fP] [\fI-n\fP]
Prints content of the one or more registers. Register start \fIADDRESS\fP and
the \fICOUNT\fP must be between 1-9999. The -n parameter does not raise a line
and the cursor does not return to the beginning of the line.
.TP
\fBprint\fP \fI$VARIABLE\fP [\fI-n\fP]
Prints value of the \fI$VARIABLE\fP. The -n parameter does not raise a line
and the cursor does not return to the beginning of the line.
.TP
\fBprint\fP "\fImessage\fP" [\fI-n\fP]
Prints a single line message. The -n parameter does not raise a line and the
cursor does not return to the beginning of the line.
.TP
\fBprintcolor\fP \fI[$]FOREGROUND\fP|\fI255\fP \fI[$]BACKGROUND\fP|\fI255\fP
Sets temporary foreground and background colors for \fBprint\fP command in CLI and TUI mode.
Value \fI255\fP sets color to default.
.EX

\fIColors:\fP
0: black  4: red         8: darkgray    12: lightred
1: blue   5: magenta:    9: lightblue   13: lightmagenta
2: green  6: brown      10: lightgreen  14: yellow
3: cyan   7: lightgray  11: lightcyan   15: white
.EE
.TP
\fBsetarrsize\fP \fIARRAY\fP \fI[[$]SIZE]\fP
Sets size of an array.
.TP
\fBvar\fP
Prints all defined variables with their values.
.TP
\fBvar\fP \fIVARIABLE\fP [\fI[$]VALUE\fP]
Defines new variable (\fVARIABLE\fP) and assign value (\fIVALUE\fP).
Use a backslash before a space.
.TP
\fBvarr\fP
Prints variable arrays with their size.
.TP
\fBvarr\fP \fIARRAY\fP
Defines new zero size \fIARRAY\fP variable array.
.TP
\fBvarr\fP \fIARRAY\fP \fISIZE\fP
Defines new \fISIZE\fP size \fIARRAY\fP variable array.
.TP
\fBvarmon\fP \fIoff\fP|\fIon\fP
Enable/disable variable monitor.
.TP
\fBvarmon\fP \fI$VARIABLE\fP \fIoff\fP|\fIon\fP
Enable/disable monitoring of the specified variable.
.TP
\fBver\fP
Shows version and build information of this program.

.SS Logical commands
.TP
\fBand\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Performs the AND operation between the two values or variables
(\fI[$]VALUE1\fP \fI[$]VALUE2\fP) and the result is placed in
\fI$TARGET\fP.
.TP
\fBbit\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Returns with the specified bit \fI[$]VALUE2\fP of the \fI[$]VALUE1\fP.
.TP
\fBnot\fP \fI$TARGET\fP \fI[$]VALUE\fP
Performs the NOT operation on value or variable (\fI[$]VALUE\fP)
and the result is placed in \fI$TARGET\fP.
.TP
\fBor\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Performs the OR operation between the two values or variables
(\fI[$]VALUE1\fP \fI[$]VALUE2\fP) and the result is placed in
\fI$TARGET\fP.
.TP
\fBroll\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Rolls bits of the \fI[$]VALUE1\fP to the left by position
\fI[$]VALUE2\fP and the result is placed in \fI$TARGET\fP.
.TP
\fBrolr\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Rolls bits of the \fI[$]VALUE1\fP to the right by position
\fI[$]VALUE2\fP and the result is placed in \fI$TARGET\fP.
.TP
\fBshl\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Shifts bits of the \fI[$]VALUE1\fP to the left by position
\fI[$]VALUE2\fP and the result is placed in \fI$TARGET\fP.
.TP
\fBshr\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Shifts bits of the \fI[$]VALUE1\fP to the right by position
\fI[$]VALUE2\fP and the result is placed in \fI$TARGET\fP.
.TP
\fBxor\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Performs the XOR operation between the two values or variables
(\fI[$]VALUE1\fP \fI[$]VALUE2\fP) and the result is placed in
\fI$TARGET\fP.

.SS Register handler commands
.TP
\fBdump\fP [\fI[dinp|coil|ireg|hreg] [$]ADDRESS\fP]
Dumps one page register content from \fIADDRESS\fP in binary/hexadecimal format
to a table.
.TP
\fBlet\fP \fIdinp\fP|\fIcoil\fP|\fIireg\fP|\fIhreg\fP \fI[$]ADDRESS\fP \fI[$]VALUE\fP
Sets value of a register. Register start address must be between 1-9999.
If register type is discrete input (\fIdinp\fP) and coil
(\fIcoil\fP), \fIVALUE\fP must be 0/1, l/h or false/true. If it is input register
(\fIireg\fP) or holding register (\fIhreg\fP), \fIVALUE\fP must be 0-65535.
.TP
\fBlet\fP \fI$VARIABLE\fP \fIdinp\fP|\fIcoil\fP|\fIireg\fP|\fIhreg\fP \fI[$]ADDRESS\fP
Sets value of a variable \fI$VARIABLE\fP from register content. Register start address
and must be between 1-9999, If register type is discrete input (\fIdinp\fP) and coil
(\fIcoil\fP), value will be 0/1, if it is input register
(\fIireg\fP) or holding register (\fIhreg\fP), value of the variable will be 0-65535.

.SS Script operation commands
.TP
\fBedit\fP [\fILINE_NUMBER\fP]
Edits loaded script with line editor.
.TP
\fBerasescr\fP
Erases script from buffer.
.TP
\fBlist\fP
Lists loaded script.
.TP
\fBloadscr\fP \fI[$]PATH_AND_FILENAME\fP
Loads ModShell scriptfile from disc.
.TP
\fBrun\fP \fI[-h]\fP \fI[-s]\fP
Runs loaded script. When the \fI[-h]\fP parameter is specified, the values​of the
variables and constants created by the script are preserved until the next run.
\fI[-s]\fP parameter means step-by-step program execution.
 .TP
\fBsavescr\fP \fI[$]PATH_AND_FILENAME\fP
Saves loaded script to disc.

.SS String handler commands
.TP
\fBchr\fP \fI$TARGET\fP \fI[$]VALUE';
Converts byte value (\fI[$]VALUE\fP) to char value and the result is placed in \fI$TARGET\fP.
.TP
\fBconcat\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Concatenates two string and the result is placed in \fI$TARGET\fP.
.TP
\fBlength\fP \fI$TARGET\fP \fI[$]VALUE\fP
Puts length of the string (\fI[$]VALUE\fP) to \fI$TARGET\fP.
.TP
\fBlowcase\fP \fI$TARGET\fP \fI[$]VALUE\fP
Converts string (\fI[$]VALUE\fP) to lowercase and the result is placed in \fI$TARGET\fP.
.TP
\fBmklrc\fP \fI$TARGET\fP \fI[$]STRING\fP
Make LRC of the \fI[$]STRING\fP
.TP
\fBmkcrc\fP \fI$TARGET\fP \fI[$]STRING\fP
Make CRC of the \fI[$]STRING\fP
.TP
\fBord\fP \fI$TARGET\fP \fI[$]VALUE\fP
Converts char value (\fI[$]VALUE\fP) to byte value and the result is placed in \fI$TARGET\fP.
.TP
\fBstrdel\fP \fI$TARGET\fP \fI[$]PLACE\fP \fI[$]COUNT\fP
Delete specified element(s) (\fI[$]PLACE\fP \fI[$]COUNT\fP) of the \fI$TARGET\fP variable.
.TP
\fBstrfind\fP \fI$TARGET\fP \fI[$]VALUE\fP
Delete specified element (\fI[$]VALUE\fP) in the \fI$TARGET\fP variable.
.TP
\fBstrins\fP \fI$TARGET\fP \fI[$]PLACE\fP \fI[$]VALUE\fP
Insert specified element (\fI[$]VALUE\fP) into the \fI$TARGET\fP variable.
.TP
\fBstritem\fP \fI$TARGET\fP \fI[$]VALUE1\fP \fI[$]VALUE2\fP
Puts specified (\fI[$]VALUE2\fP) element of the string (\fI[$]VALUE1\fP) to \fI$TARGET\fP.
.TP
\fBstrrepl\fP \fI$TARGET\fP \fI[$]OLD\fP \fI[$]NEW\fP
Replace specified element (\fI[$]OLD\fP) to \fI[$]NEW\fP in the \fI$TARGET\fP variable.
.TP
\fBupcase\fP \fI$TARGET\fP \fI[$]VALUE\fP
Converts string (\fI[$]VALUE\fP) to uppercase and the result is placed in \fI$TARGET\fP.

.SS File and directory management system commands
.TP
\fBdir\fP \fI[[$]PATH_AND_DIRECTORYNAME]\fP
Lists content of actual or \fI[[$]PATH_AND_DIRECTORYNAME]\fP directory.
.TP
\fBcd\fP
Gets name of the actual directory.
.TP
\fBcd\fP \fI[[$]PATH_AND_DIRECTORYNAME]\fP
Changes actual directory to \fI[[$]PATH_AND_DIRECTORYNAME]\fP.
.TP
\fBchkdevlock\fP \fI[$]DEVICE\fP
Check \fI[$]DEVICE\fP device lock file.
.TP
\fBcopy\fP \fI[$]PATH_AND_FILENAME\fP \fI[$]NEW_PATH_AND_FILENAME\fP
Copies \fI[$]PATH_AND_FILENAME\fP file to \fI[$]NEW_PATH_AND_FILENAME\fP.
.TP
\fBdel\fP \fI[$]PATH_AND_FILENAME\fP
Removes \fI[$]PATH_AND_FILENAME\fP file.
.TP
\fBexist\fP \fI[$]PATH_AND_FILENAME\fP
Existence of \fI[$]PATH_AND_FILENAME\fP file or directory.
.TP
\fBmd\fP \fI[$]PATH_AND_DIRECTORYNAME\fP
Makes a directory.
.TP
\fBrd\fP \fI[$]PATH_AND_DIRECTORYNAME\fP
Removes \fI[$]PATH_AND_DIRECTORYNAME\fP directory if empty.
.TP
\fBren\fP \fI[$]PATH_AND_FILENAME\fP \fI[$]NEW_PATH_AND_FILENAME\fP
Renames \fI[$]PATH_AND_FILENAME\fP file to \fI[$]NEW_PATH_AND_FILENAME\fP.
.TP
\fBrmdevlock\fP \fI[$]DEVICE\fP
Remove \fI[$]DEVICE\fP device lock file.
.TP
\fBtype\fP \fI[$]PATH_AND_FILENAME\fP
Lists content \fI[$]PATH_AND_FILENAME\fP file.
.SH EXAMPLES
.SS Arithmetical commands
.TP
\fBadd\fP $result 12 13
Adds 12 and 13, and the result is placed in $result.
.TP
\fBconv\fP $result bin hex 1011000010110100
Convert 45236 in binary to hexadecimal, result placed in $result (B0B4).
.TP
\fBconv\fP $result hex dec $i
Convert value of the $i in hexadecimal to decimal. Result placed in $result.
.TP
\fBround\fP $result 12.01023 2
Round 12.01023 to decimal places, and the result (12.01)
is placed in $result.
.TP
\fBsubs\fP $result 12 13
Substract 13 from 12, and the result is placed in $result.

.SS Communication commands
.TP
\fBcopyreg\fP con0 ireg con2 hreg 210 10
Copy input register content of the connection #0 to holding register content of the
connection #2 from address 210 to 220.
.TP
\fBcopyreg\fP con0 ireg con2 hreg $a $b
Copy input register content of the connection #0 to holding register content of the
connection #2 from address value of the $a to $a+$b.
.TP
\fBreadreg\fP con0 hreg 100 15
Read remote holding registers of the connection #0 from address 100 to 115.
.TP
\fBreadreg\fP con0 hreg $a 15
Read remote holding registers of the connection #0 from address value of the $a to $a+15.
.TP
\fBsercons\fP
Open serial console with requesting device number.
.TP
\fBsercons\fP dev0
Open serial console with dev0 device.
.TP
\fBserread\fP dev0
Read string from dev0 device and write to screen.
.TP
\fBserread\fP dev0 $target
Read string from dev0 device and write to $target variable.
.TP
\fBserwrite\fP dev0 "The\ quick\ brown\ fox\ jumps\ over\ the\ lazy\ dog."
Write string to dev0 device.
.TP
\fBserwrite\fP dev0 "$message"
Write string from $message variable to dev0 device.
.TP
\fBwritereg\fP con2 coil 10
Write data from to coil address 10 of the connection #2.
.TP
\fBwritereg\fP con2 coil $c
Write data from to coil address value of the $c of the connection #2.

.SS Configuration commands
.TP
\fBget\fP dev2
Get configuration of a device #2.
.TP
\fBreset\fP project
Reset project name (project name will be 'default').
.TP
\fBset\fP dev0 net /dev/enp0s7 192.168.10.11 502
Set device #0 to '/dev/enp0s7' ethernet device with 192.168.10.11 IP-address and 502 port.
.TP
\fBset\fP dev0 net /dev/enp0s7 $A $P
Set device #0 to '/dev/enp0s7' ethernet device with value of the $A IP-address and $P port.
.TP
\fBset\fP dev1 ser ttyS0 9600 8 N 1
Set device #1 to /dev/ttyS0 serial device, with 9600 baud, 8 databits,
without parity check and 1 stopbit.
.TP
\fBset\fP dev1 ser COM1 9600 8 N 1
Set device #1 to COM1 serial device, with 9600 baud, 8 databits,
without parity check and 1 stopbit.
.TP
\fBset\fP dev1 ser $p $s $d $p $t
Set device #1 to $p serial device, with $s baud, $d databits, $p
parity check and $t stopbit.
.TP
\fBset\fP pro0 ascii 100
Set protocol #0 to Modbus/ASCII with 100 unit ID (slave).
.TP
\fBset\fP con0 dev0 pro2
Assigns a device #0 and protocol #2 to connection #0.
.TP
\fBset\fP project temp_meter
Set the project name to 'temp_meter'.
.TP
\fBset\fP timeout 1000
Set the connection timeout to 1 s.

.SS File operation commands
.TP
\fBapplog\fP $LOGFILE "Measured\ values\ is\ $$1\ V\ and\ $$2\ A." 1 $vl2 $il2
Adds \fI2024.2.1. 17:20:36 MESSAGE Measured values is 243 V and 66 A.\fP line
to logfile.
.TP
\fBexphis\fP script
Export command line history to project directory.
.TP
\fBexpreg\fP discrete_inputs.csv dinp 100 15
Export values of discrete input register from address 100 to 115
to CSV file.
.TP
\fBimpreg\fP discrete_inputs.xml
Import values from a XML file. The target and range are determined by the
contents of the file.
.TP
\fBloadcfg\fP test1
Load settings of device, protocol and connection from project directory.
.TP
\fBloadreg\fP /home/username/Desktop/test1
Load all registers from other directory.
.TP
\fBsavecfg\fP test1
Save settings of device, protocol and connection to project directory.
.TP
\fBsavereg\fP /home/username/Desktop/test1
Save all registers to other directory.

.SS General commands
.TP
\fBcron\fP 2 15 *
Run the loaded script at the 15th minute of every hour.
 .TP
\fBcron\fP -r 2
Removes 2nd record from the crontable.
.TP
\fBecho\fP
Query local echo status.
.TP
\fBecho\fP on
Enable local echo it for serial connections.
.TP
\fBecho\fP hex
Enable local echo with hexadecimal representation of the bytes.
.TP
\fBhelp\fP
Show short description of the useable commands.
.TP
\fBhelp\fP set
Show usage of help command.
.TP
\fBlet\fP $a 10
Set $a variable to 10.
.TP
\fBlet\fP $a $b
Set $a variable to value of $b.
.TP
\fBpause\fP
Wait for a key press.
.TP
\fBpause\fP 5
Wait for 5 sec.
.TP
\fBpause\fP $time
Wait for value of the $time sec.
.TP
\fBprint\fP $a -n
Print value of the $a variable without new line.
.TP
\fBprint\fP "Hello\ world!"
Print 'Hello world!' message.
.TP
\fBvar\fP A 12
Define $a variable and assign 12 value to it.
.TP
\fBvar\fP B $a
Define $b variable and assign value of the $a.

.SS Logical commands
.TP
\fBand\fP $result 1234 1345
Performs AND operation with 1234 and 1345, and the
result is placed in $result.
.TP
\fBor\fP $result 1234 $b
Performs OR operation with 1234 and $b, and the
result is placed in $result.
.TP
\fBnot\fP $result $a
Performs negation on 1234 and the
result is placed in $result.
.TP
\fBshr\fP $result $source $shift
Shifts bits of the $source to the left by position
$shift and the result is placed in $result.

.SS Register handler commands
.TP
\fBdump\fP
Start dump with requesting register type and start address.
.TP
\fBdump\fP hreg 1121
Start discrete input register dump from address 1121.
.TP
\fBlet\fP dinp 10 1
Set value of the discrete input register address 10 to 1.
.TP
\fBlet\fP dinp 10 true
Set value of the discrete input register address 10 to 1.
.TP
\fBlet\fP dinp 10 H
Set value of the discrete input register address 10 to 1.
.TP
\fBlet\fP ireg 10 65535
Set value of the input register address 10 to 65535.
.TP
\fBlet\fP ireg $a $b
Set value of the input register (address value of the $a) to value of the $b.
.TP
\fBlet\fP $a ireg 100
Set $a to input register address 100.
.TP
\fBprint\fP ireg 10 10
Print value of the input register address 10 to 20.
.TP
\fBprint\fP ireg $a $b
Print value of the input register address value of $a to value of $b.

.SS Script operation commands
.TP
\fBloadscr\fP /home/username/Desktop/dt510
Load dt510 scriptfile other directory.
.TP
\fBrun\fP -s -h
Run loaded script step-by-step and reserve variables until next run.

.SS String handler commands
.TP
\fBchr\fP $ch $b
Convert byte type value in $b to character and the result is placed in $ch.
.TP
\fBlength\fP $length "abcdef"
Put length of the specified string to $length variable.
.TP
\fBstritem\fP $char $name 5
Put 5th element of the $name string to $char variable.
.TP
\fBupcase\fP $target $title
Convert string in title to uppercase and the result is placed in $target.

.SS System commands
.TP
\fBtype\fP $LOGFILE
List file in $LOGFILE to console.
.TP
\fBren\fP $LOGFILE backup
Rename file in $LOGFILE to "backup.bak".
.SH HOTKEYS
Commands with function keys (\fBF?\fP) are executed immediately,
modifier keys (\fBALT\fP-\fB?\fP) only make typing easier.
.TP
\fBUP\fP
scroll up command line history
.TP
\fBDOWN\fP
scroll down command line history
.TP
\fBESC\fP
clear command line
.TP
\fBENTER\fP
run command
.TP
\fBF1\fP
help command
.TP
\fBF2\fP
savecfg command
.TP
\fBF3\fP
loadcfg command
.TP
\fBF4\fP
savereg command
.TP
\fBF5\fP
loadreg command
.TP
\fBF6\fP
dump command
.TP
\fBF7\fP
sercons command
.TP
\fBF8\fP
cls command
.TP
\fBF9\fP
echo swap command
.TP
\fBF10\fP
exit command
.TP
\fBSHIFT\fP-\fBF3\fP
list loaded script
.TP
\fBSHIFT\fP-\fBF4\fP
edit loaded script (with line editor)
.TP
\fBSHIFT\fP-\fBF8\fP
erase script from buffer
.TP
\fBSHIFT\fP-\fBF9\fP
run loaded script
.TP
\fBALT\fP-\fBC\fP
conv command
.TP
\fBALT\fP-\fBE\fP
expreg command
.TP
\fBALT\fP-\fBG\fP
get command
.TP
\fBALT\fP-\fBI\fP
impreg command
.TP
\fBALT\fP-\fBL\fP
let command
.TP
\fBALT\fP-\fBM\fP
monitoring the value of variables
.TP
\fBALT\fP-\fBP\fP
print command
.TP
\fBALT\fP-\fBR\fP
readreg command
.TP
\fBALT\fP-\fBT\fP
reset command
.TP
\fBALT\fP-\fBS\fP
set command
.TP
\fBALT\fP-\fBW\fP
writereg command
.SH ENVIRONMENTAL VARIABLES
.TP
.B LANG
This is the system language on DOS and Unix-like operating systems.
.TP
.B PKTDRVINT
To access the network on DOS, the packet driver of the network card is
required. It uses an x86 interrupt number (INT) between 0x60 and 0x80. This
variable tells the program this value. If there is no or it is empty, then
the default 0x60 will be used.
.SH FILES
.TP
.B modshell.ini
General configuration file in user's directory on Windows or Unix-like system
or in the settings folder of the program on DOS.
.TP
.B console.log
Serial console traffic.
.TP
.B scriptfiles[.bat]
The script file is used for batch execution of ModShell commands. The commands
must be entered in the same form as if we were working in the built-in command
line. If the first valuable character (not a space or tab) of a line is a hash,
then that line is not interpreted. You can find examples in the documents library.

A simple example on Unix-like OS:

.EX
#!/usr/local/bin/modshell -r

# Example script * use of variables
print "Example\ script\ -\ How\ to\ use\ variables?"
print "--------------------------------------------"
var a 24
var b
var c 
let $b 2
 (...)
print "The\ sum\ of\ $A\ and\ $B:"
print "--------------------------------------------"
.EE

A simple example on DOS and Windows OS:

.EX
@modshell.exe -r %0
@goto :eof

# Example script * use of variables
print "Example\ script\ -\ How\ to\ use\ variables?"
print "--------------------------------------------"
var a 24
var b
var c 
let $b 2
 (...)
print "The\ sum\ of\ $A\ and\ $B:"
print "--------------------------------------------"

:eof
.EE

.TP
.B "*.DDT"
Saved device setting in typed file with seven TDevice type values.
.EX
type TDevice = record
       valid: boolean;     // settings validity: false|true
       devtype: byte;      // type of device: 0..1 -> see DEV_TYPE
       device: string[15]; // device: /dev/ttySx, COMx, /dev/eth0 etc.
       port: word;         // ethernet port: 0-65535
       speed: byte;        // serial speed: 0..7 -> see DEV_SPEED
       databit: byte;      // serial databits: 7|8
       parity: byte;       // serial parity: 0..2 -> see DEV_PARITY
       stopbit: byte;      // serial stopbit: 1|2
     end;
.EE
.TP
.B "*.PDT"
Saved protocol setting in typed file with seven TProtocol type values.
.EX
type TProtocol = record
       valid: boolean;        // settings validity: false|true
       prottype: byte;        // type of protocol: 0..2 -> see PROT_TYPE
       ipaddress: string[15]; // IP address in a.b.c.d format
       ID: integer;          // Modbus Unit ID: 1..247
     end;
.TP
.B "*.CDT"
Saved connection setting in typed file with seven TConnection type values.
.EX
type TConnection = record
       valid: boolean;        // settings validity: false|true
       dev: byte;             // assigned device: 0..7
       prot: byte;            // assigned protocol: 0..7
     end;
.EE
.TP
.B "*.BDT"
Saved boolean type register values in typed file with 2x9999 boolean values.
.TP
.B "*.WDT"
Saved word type register values in typed file with 2x9999 word values.
.TP
.B "*.CSV"
Exported boolean or word type register values in CSV text file. Cannot be imported.
Internal structure:
.EX
  dinp,1,0
      ...
  dinp,9999,1
  coil,1,0
      ...
  coil,9999,1
  ireg,1,102
      ...
  ireg,9999,33332
  hreg,1,5342
      ...
  hreg,9999,12
.EE
.TP
.B "*.INI"
Exported register values in INI text file in this structure:
.EX
  [dinp]
  addr_1=0
    ...
  addr_9999=1

  [coil]
  addr_1=0
    ...
  addr_9999=1

  [ireg]
  addr_1=102
    ...
  addr_9999=33332

  [hreg]
  addr_1=5342
    ...
  addr_9999=12
.EE
.TP
.B "*.XML"
Exported register values in XML text file in this structure:
.EX
  <?xml version="1.0" encoding="utf-8"?>
  <xml>
    <dinp>
      <reg addr="1">0</reg>
              ...
      <reg addr="9999">1</reg>
    </dinp>
    <coil>
      <reg addr="1">0</reg>
              ...
      <reg addr="9999">1</reg>
    </coil>
    <ireg>
      <reg addr="1">102</reg>
              ...
      <reg addr="33332">1</reg>
    </ireg>
    <hreg>
      <reg addr="1">5342</reg>
              ...
      <reg addr="33332">12</reg>
    </hreg>
  </xml>
.EE
.SH EXIT STATUS
.TP
.B 0
Normal exit.
.TP
.B 1
Terminal size is smaller than 80x25 characters.
.TP
.B 2
The specified script file does not exist.
.TP
.B 3
The specified script file cannot be loaded.
.TP
.B 4
Script buffer is full.
.SH HOMEPAGE
.UR http://www.pozsarzs.hu
.UE
.PP
.UR https://pozsarzs.github.io/modshell
.UE
.PP
.UR https://github.com/pozsarzs/modshell
.UE
.SH SEE ALSO
.PD 0
.LP
\fBxmodshell\fP(1)
.LP
and files in document or /usr/share/doc/modshell/ folder (or equivalent on your system).
.SH AUTHOR
Pozsar Zsolt
.MT pozsarzs@gmail.com
.ME
